//  __  __         _          _         ___                        _   
// |  \/  |  __ _ | |_  _ __ (_)__  __ / _ \  _   _   __ _  _ __  | |_ 
// | |\/| | / _` || __|| '__|| |\ \/ /| | | || | | | / _` || '_ \ | __|
// | |  | || (_| || |_ | |   | | >  < | |_| || |_| || (_| || | | || |_ 
// |_|  |_| \__,_| \__||_|   |_|/_/\_\ \__\_\ \__,_| \__,_||_| |_| \__|
// 
// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© MatrixQuantLabs
//
//@version=6
indicator(title = 'Multi-Factor Reversal Analyzer', shorttitle='‚òÖ Multi-Factor Reversal Analyzer‰∏®Â§öÂõ†Â≠êÂèçËΩ¨ÂàÜÊûêÂô® ‚òÖ', overlay=false)

//Trend Detector‰∏®Ë∂ãÂäøÊé¢ÊµãÂô®
EnableTrendDetector = input.bool(true, title = 'Enable Trend Detector‰∏®ÂêØÁî®Ë∂ãÂäøÊé¢ÊµãÂô®', group = 'Trend Detector‰∏®Ë∂ãÂäøÊé¢ÊµãÂô®', tooltip = '‚ñ∂Ô∏é The Trend Detector analyzes price and volume momentum to output a composite trend strength score. Higher values indicate stronger trends. It helps identify potential tops, bottoms, or trend continuation zones. For best results, use alongside other indicators or price action.\n‚ñ∂Ô∏é The indicator performs optimally when used in conjunction with a harmonic pattern recognition tool.\n‚ñ∂Ô∏é Ë∂ãÂäøÊé¢ÊµãÂô®Áî®‰∫éÁªºÂêàÂàÜÊûê‰ª∑Ê†º‰∏éÊàê‰∫§ÈáèÁöÑÂ§öÁ©∫Âä®ËÉΩÂº∫Âº±ÔºåËæìÂá∫Ë∂ãÂäøÂº∫Â∫¶ÂàÜÂÄº„ÄÇÊï∞ÂÄºË∂äÈ´ò‰ª£Ë°®Ë∂ãÂäøË∂äÂº∫ÔºåÂ§öÁî®‰∫éËØÜÂà´È°∂ÈÉ®„ÄÅÂ∫ïÈÉ®ÊàñË∂ãÂäøÂª∂Áª≠Áä∂ÊÄÅÔºåÂª∫ËÆÆÁªìÂêàÂÖ∂‰ªñ‰ø°Âè∑ËæÖÂä©Âà§Êñ≠‰∫§ÊòìÊñπÂêë„ÄÇ\n‚ñ∂Ô∏é ‰∏éË∞êÊ≥¢ÂΩ¢ÊÄÅËØÜÂà´Â∑•ÂÖ∑ÁªìÂêà‰ΩøÁî®Êó∂ÔºåËØ•ÊåáÊ†áË°®Áé∞ÊúÄ‰Ω≥„ÄÇ')
OHLCtrendLength = input.int(8, title = 'OHLC Trend Length‰∏®Âõõ‰ª∑Ë∂ãÂäøÈïøÂ∫¶', minval = 1, group = 'Trend Detector‰∏®Ë∂ãÂäøÊé¢ÊµãÂô®')
CloseTrendLength = input.int(20, title = 'Close Trend Length‰∏®Êî∂Áõò‰ª∑Ë∂ãÂäøÈïøÂ∫¶', minval = 1, group = 'Trend Detector‰∏®Ë∂ãÂäøÊé¢ÊµãÂô®')

OhlcDirectionalWeight = close == high and close == low or high == low ? 0 : (2 * close - low - high) / (high - low) * volume
OhlcTrendStrength = math.sum(OhlcDirectionalWeight, 1) / math.sum(volume, 1)
OhlcUpStrength = math.sum(volume * (ta.change(ohlc4) <= 0 ? 0 : ohlc4), OHLCtrendLength)
OhlcDownStrength = math.sum(volume * (ta.change(ohlc4) >= 0 ? 0 : ohlc4), OHLCtrendLength)
paramaters(UpStrengthA, DownStrengthA) =>
    if DownStrengthA == 0
        100
    if UpStrengthA == 0
        0
    100.0 - 100.0 / (1.0 + OhlcUpStrength / OhlcDownStrength)
OHLCtrendLine = paramaters(OhlcUpStrength, OhlcDownStrength)

CloseDirectionalWeight = close == high and close == low or high == low ? 0 : (2 * close - low - high) / (high - low) * volume
CloseTrendStrength = math.sum(CloseDirectionalWeight, 1) / math.sum(volume, 1)
CloseUpStrength = math.sum(volume * (ta.change(close) <= 0 ? 0 : close), CloseTrendLength)
CloseDownStrength = math.sum(volume * (ta.change(close) >= 0 ? 0 : close), CloseTrendLength)
paramaters2(UpStrengthB, DownStrengthB) =>
    if DownStrengthB == 0
        100
    if UpStrengthB == 0
        0
    100.0 - 100.0 / (1.0 + CloseUpStrength / CloseDownStrength)
CloseTrendLine = paramaters2(CloseUpStrength, CloseDownStrength)

OverboughtA = hline(100, color = color.new(#ff0000, 0), linestyle = hline.style_solid, title = 'Overbought Line-A‰∏®Ë∂Ö‰π∞Á∫ø-A')
OverboughtB = hline(85, color = color.new(#ff0000, 50), linestyle = hline.style_solid, title = 'Overbought Line-B‰∏®Ë∂Ö‰π∞Á∫ø-B')
OverboughtC = hline(70, color = color.new(#ff0000, 75), linestyle = hline.style_solid, title = 'Overbought Line-C‰∏®Ë∂Ö‰π∞Á∫ø-C')
OversoldC = hline(30, color = color.new(#00ff00, 75), linestyle = hline.style_solid, title = 'Oversold Line-C‰∏®Ë∂ÖÂçñÁ∫ø-C')
OversoldB = hline(15, color = color.new(#00ff00, 50), linestyle = hline.style_solid, title = 'Oversold Line-B‰∏®Ë∂ÖÂçñÁ∫ø-B')
OversoldA = hline(0, color = color.new(#00ff00, 0), linestyle = hline.style_solid, title = 'Oversold Line-A‰∏®Ë∂ÖÂçñÁ∫ø-A')
plot(EnableTrendDetector ? OHLCtrendLine + OhlcTrendStrength / CloseTrendLine + CloseTrendStrength : na, 'Trend Detector Line‰∏®Ë∂ãÂäøÊé¢ÊµãÁ∫ø', style = plot.style_histogram, color = color.new(color.yellow, 65))
//Trend Detector‰∏®Ë∂ãÂäøÊé¢ÊµãÂô®


// Gold Zone‰∏®ÈªÑÈáëÂùë
ShowGoldZone = input.bool(true, title = 'Show Gold Zone‰∏®ÊòæÁ§∫ÈªÑÈáëÂùë', group = 'Gold Zone‰∏®ÈªÑÈáëÂùë', tooltip = '‚ñ∂Ô∏é The Gold Zone is used to identify extreme states of price volatility and momentum, signaling an upcoming significant price move. You should combine it with other indicators to determine the bullish or bearish trend.\n‚ñ∂Ô∏é ÈªÑÈáëÂùëÁî®‰∫éËØÜÂà´‰ª∑Ê†ºÊ≥¢Âä®ÂíåÂä®ËÉΩÊûÅÈôêÁä∂ÊÄÅÔºåÈ¢ÑÁ§∫Âç≥Â∞ÜÂá∫Áé∞‰∏ÄÊ¨°ËæÉÂ§ßÊ≥¢Âä®ÁöÑË°åÊÉÖÔºå‰Ω†ÈúÄË¶ÅÁªìÂêàÂ§öÁßçÊåáÊ†áÂà§Êñ≠Â§öÁ©∫Ë∂ãÂäø„ÄÇ')
GoldZoneLength = input(8, title = 'Gold Zone Length‰∏®ÈªÑÈáëÂùëÈïøÂ∫¶', group = 'Gold Zone‰∏®ÈªÑÈáëÂùë')
GoldZoneThreshold = input.float(30, title = 'Gold Zone Threshold‰∏®ÈªÑÈáëÂùëÈòàÂÄº', minval = 0, maxval = 30, step = 1, group = 'Gold Zone‰∏®ÈªÑÈáëÂùë')
GoldZoneSRC = input(hlc3, title = 'Data Source‰∏®Êï∞ÊçÆÊ∫ê', group = 'Gold Zone‰∏®ÈªÑÈáëÂùë')
PI = 3.14159265359

ModeType = 'Standard'
SimpleHarmonicType = 'Simple Harmonic'
RSItype = 'RSI'
KarobeinType = 'Karobein'
MoscillatorType = 'M-Oscillator'
CalculationType = RSItype

PriceVolatility(PriceSrc, SmoothingLen) =>
    math.sqrt(PriceSrc / (SmoothingLen * 4 * math.log(2)) * math.sum(math.pow(math.log(high / low), 2), SmoothingLen))

RMA(PriceSrc, SmoothingLen) =>
    ta.sma(PriceSrc, SmoothingLen * 3) + ta.sma(PriceSrc, SmoothingLen * 2) - ta.sma(PriceSrc, SmoothingLen)

GoldZoneRSI(PriceSrc, SmoothingLen) =>
    UpMove = math.max(PriceSrc - PriceSrc[1], 0)
    DownMove = math.max(PriceSrc[1] - PriceSrc, 0)
    RelativeStrength = ta.rma(UpMove, SmoothingLen) / ta.rma(DownMove, SmoothingLen)
    RSIvalue = 100 - 100 / (1 + RelativeStrength)
    RSIvalue

SimpleHarmonic(PriceSrc, SmoothingLen) =>
    CurrentPrice = PriceSrc
    PreviousPrice = CurrentPrice[1]
    PastPrice = CurrentPrice[2]
    CurrentVelocity = CurrentPrice - PreviousPrice
    PreviousVelocity = PreviousPrice - PastPrice
    RawAcceleration = CurrentVelocity - PreviousVelocity
    SmoothedAcceleration = ta.ema(RawAcceleration, SmoothingLen)
    OscillationPeriod = 2 * PI * math.sqrt(math.abs(CurrentVelocity / SmoothedAcceleration))
    DirectionalPeriod = CurrentPrice > PreviousPrice ? OscillationPeriod : OscillationPeriod * -1
    SmoothedDirectionalPeriod = ta.ema(DirectionalPeriod, SmoothingLen)
    SmoothedOscillationPeriod = ta.ema(OscillationPeriod, SmoothingLen)
    SimpleHarmonicOscillator = SmoothedDirectionalPeriod / SmoothedOscillationPeriod * 100
    SimpleHarmonicOscillator

Karobein(PriceSrc, SmoothingLen) =>
    KarobeinSRC = ta.ema(PriceSrc, SmoothingLen)
    DownRatio = ta.ema(KarobeinSRC < KarobeinSRC[1] ? KarobeinSRC / KarobeinSRC[1] : 0, SmoothingLen)
    UpRatio = ta.ema(KarobeinSRC > KarobeinSRC[1] ? KarobeinSRC / KarobeinSRC[1] : 0, SmoothingLen)
    TrendRatio = KarobeinSRC / KarobeinSRC[1] / (KarobeinSRC / KarobeinSRC[1] + UpRatio)
    KarobeinSignal = 2 * (KarobeinSRC / KarobeinSRC[1] / (KarobeinSRC / KarobeinSRC[1] + TrendRatio * DownRatio)) - 1
    KarobeinSignal

Moscillator(PriceSrc, SmoothingLen) =>
    CumulativeTrendScore = 0
    for Index = 1 to SmoothingLen by 1
        CurrentPrice = PriceSrc[0]
        LookbackPrice = PriceSrc[Index]
        TrendScore = CurrentPrice > LookbackPrice ? 1 : CurrentPrice < LookbackPrice ? -1 : 0
        CumulativeTrendScore := CumulativeTrendScore + TrendScore
        CumulativeTrendScore
    CumulativeTrendScore

CalculateOscillator(CalculationMode, PriceSrc, SmoothingLen) =>
    CalculationMode == ModeType ? PriceVolatility(GoldZoneSRC, GoldZoneLength) : CalculationMode == RSItype ? GoldZoneRSI(PriceVolatility(GoldZoneSRC, GoldZoneLength), SmoothingLen) : CalculationMode == SimpleHarmonicType ? SimpleHarmonic(PriceVolatility(GoldZoneSRC, GoldZoneLength), SmoothingLen) : CalculationMode == KarobeinType ? Karobein(PriceVolatility(GoldZoneSRC, GoldZoneLength), SmoothingLen) : CalculationMode == MoscillatorType ? ta.ema(ta.ema(Moscillator(PriceVolatility(GoldZoneSRC, GoldZoneLength), SmoothingLen), 5), 3) : na

TypeA = CalculationType
TypeB = TypeA == ModeType ? GoldZoneSRC : PriceVolatility(GoldZoneSRC, GoldZoneLength)
TypeC = TypeA == ModeType ? GoldZoneLength : GoldZoneLength

GoldZoneRSI = CalculateOscillator(TypeA, TypeB, TypeC)

// ÈªÑÈáëÂùëÂèÇËÄÉÁ∫øÔºàÈöêËóèÔºâ
GoldZoneLevelHidden = plot(30, title = 'Gold Zone Plot Line‰∏®ÈªÑÈáëÂùëÁªòÂà∂Á∫ø', display = display.none)
// ËÆ°ÁÆó 30 ‰ª•‰∏ãÁöÑÂå∫ÂüüÔºå‰ΩÜ‰∏çÊòæÁ§∫Á∫ø
GoldZoneBelowHidden = plot(ShowGoldZone and GoldZoneRSI < GoldZoneThreshold ? GoldZoneRSI : na, style = plot.style_linebr, display = display.none, title = 'Gold Zone Level‰∏®ÈªÑÈáëÂùëÊ∞¥Âπ≥Á∫ø')
// Â°´ÂÖÖ30‰ª•‰∏ãÂèÇËÄÉÁ∫ø‰πãÈó¥ÁöÑÂå∫Âüü
fill(GoldZoneLevelHidden, GoldZoneBelowHidden, color = ShowGoldZone ? color.new(color.yellow, 0) : na, title = 'Gold Zone Fill‰∏®ÈªÑÈáëÂùëÂ°´ÂÖÖ')
// Gold Zone‰∏®ÈªÑÈáëÂùë


// Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø
EnableWaveTrend = input.bool(true, title = "Enable Wave Trend Indicator‰∏®ÂêØÁî®Ê≥¢Êµ™Ë∂ãÂäø", group = "Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø", tooltip = '‚ñ∂Ô∏é Wave Trend is an oscillator-based indicator that uses smoothed main and signal lines to identify trend strength, turning points, and divergences, making it effective in both trending and ranging markets.\n‚ñ∂Ô∏é Ê≥¢Êµ™Ë∂ãÂäøÊòØ‰∏ÄÁßçÂü∫‰∫éÈúáËç°Âô®ÁöÑÊäÄÊúØÊåáÊ†áÔºåÂà©Áî®Âπ≥ÊªëÁöÑ‰∏ªÁ∫ø‰∏é‰ø°Âè∑Á∫øËØÜÂà´Ë∂ãÂäøÂº∫Âº±„ÄÅÊãêÁÇπ‰∏éËÉåÁ¶ª‰ø°Âè∑ÔºåÈÄÇÁî®‰∫éË∂ãÂäø‰∏éÈúáËç°Ë°åÊÉÖ‰∏≠ÁöÑ‰π∞ÂçñÂÜ≥Á≠ñ„ÄÇ')
WTchanLen = input(title = 'Wave Trend Channel Length‰∏®Ê≥¢Êµ™Ë∂ãÂäøÈÄöÈÅìÈïøÂ∫¶', defval = 10, group = 'Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø') 
WTavgLen = input(title = 'Wave Trend Average Length‰∏®Ê≥¢Êµ™Ë∂ãÂäøÂπ≥ÂùáÈïøÂ∫¶', defval = 21, group = 'Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø') 
EnableLagFilter = input(title = 'Apply Laguerre Smoothing‰∏®ÂêØÁî®ÊãâÁõñÂ∞îÊª§Ê≥¢', defval = false, group = 'Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø')
LagGamma = input(title = 'Laguerre Gamma', defval = 0.02, group = 'Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø')

Laguerre(g, p) =>  // Laguerre PPO Code from TheLark
    L0 = 0.0
    L0 := (1 - g) * p + g * nz(L0[1])
    L1 = 0.0
    L1 := -g * L0 + nz(L0[1]) + g * nz(L1[1])
    L2 = 0.0
    L2 := -g * L1 + nz(L1[1]) + g * nz(L2[1])
    L3 = 0.0
    L3 := -g * L2 + nz(L2[1]) + g * nz(L3[1])
    (L0 + 2 * L1 + 2 * L2 + L3) / 6

AvgPrice = hlc3
ExpSmoothAvg = ta.ema(AvgPrice, WTchanLen)
AbsPriceDev = math.abs(AvgPrice - ExpSmoothAvg)
SmoothDev = ta.ema(AbsPriceDev, WTchanLen)
CompIndex = (AvgPrice - ExpSmoothAvg) / (0.015 * SmoothDev)
TrendCompIndex = ta.ema(CompIndex, WTavgLen)

LagSmoothedTCI = Laguerre(LagGamma, TrendCompIndex)
WTlineRaw = EnableLagFilter ? LagSmoothedTCI : TrendCompIndex
SignalLineRaw = ta.sma(WTlineRaw, 4)
HistRaw = WTlineRaw - SignalLineRaw

WTlineRawNorm = (WTlineRaw + 100) / 2
SignalLineRawNorm = (SignalLineRaw + 100) / 2
HistRawNorm = (HistRaw + 100) / 2

WTlinePlot = plot(EnableWaveTrend ? WTlineRawNorm : na, title="Wave Trend Line‰∏®Ê≥¢Êµ™Ë∂ãÂäøÁ∫ø", color=color.new(color.aqua, 0))
SignalPlot = plot(EnableWaveTrend ? SignalLineRawNorm : na, title="Signal Line‰∏®‰ø°Âè∑Á∫ø", color=color.new(color.fuchsia, 0))
WTfillColor = WTlineRawNorm > SignalLineRawNorm ? color.new(color.aqua, 80) : color.new(color.fuchsia, 80)
fill(WTlinePlot, SignalPlot, color=EnableWaveTrend ? WTfillColor : na, title="WT Fill‰∏®Ê≥¢Êµ™Ë∂ãÂäøÂ°´ÂÖÖ")

histCenter = 50.0
histColor = HistRawNorm >= histCenter ? color.new(color.aqua, 75) : color.new(color.fuchsia, 75)
HistUpLine = plot(EnableWaveTrend ? HistRawNorm : na, title="Histogram Track Line‰∏®Áõ¥ÊñπÂõæËΩ®ËøπÁ∫ø", color=na, display=display.none)
HistDownLine = plot(EnableWaveTrend ? histCenter : na, title="Histogram Midline‰∏®Áõ¥ÊñπÂõæ‰∏≠Á∫ø", color=na, display=display.none)
fill(HistUpLine, HistDownLine, color=EnableWaveTrend ? histColor : na, title="Histogram Fill‰∏®Áõ¥ÊñπÂõæÂ°´ÂÖÖ")

WTshowRegularDiv = input.bool(true, title = 'Show Regular Divergence‰∏®ÊòæÁ§∫Â∏∏ËßÑËÉåÁ¶ª', group='Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø')
WTshowHiddenDiv = input.bool(false, title = 'Show Hidden Divergence‰∏®ÊòæÁ§∫ÈöêËóèËÉåÁ¶ª', group='Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø')
WTdivSRC = input.string(title='Divergence Source‰∏®ËÉåÁ¶ªÊï∞ÊçÆÊ∫ê', defval='Histogram', options=['Wave Trend', 'Signal', 'Histogram'], group='Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø')
WTpvtLBr = input(title = 'Pivot Lookback Right‰∏®ÂêëÂè≥ÂõûÊ∫ØÈïøÂ∫¶', defval = 1, group = 'Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø', tooltip = '‚ñ∂Ô∏é Confirms a pivot only if future candles don‚Äôt surpass the current value. Higher values delay confirmation but improve stability and reduce false signals.\n‚ñ∂Ô∏é ‰ªÖÂΩìÂâçÊñπÁöÑ K Á∫øÈÉΩÊú™Á™ÅÁ†¥ÂΩìÂâçÂÄºÊó∂ÔºåÊâçËÉΩÁ°ÆËÆ§ÂÖ∂‰∏∫Êû¢ËΩ¥ÁÇπ„ÄÇÊï∞ÂÄºË∂äÂ§ßÔºåÁ°ÆËÆ§Ë∂äÊªûÂêéÔºå‰ΩÜÊõ¥Á®≥ÂÆöÔºåÂèØÂáèÂ∞ëËØØÊä•„ÄÇ')
WTpvtLBl = input(title = 'Pivot Lookback Left‰∏®ÂêëÂ∑¶ÂõûÊ∫ØÈïøÂ∫¶', defval = 5, group = 'Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø', tooltip = '‚ñ∂Ô∏é When identifying highs/lows, a larger left-side lookback requires more stable past movement, making detection more cautious but more reliable.\n‚ñ∂Ô∏é Áî®‰∫éËØÜÂà´ÂΩìÂâçÊòØÂê¶‰∏∫È´ò/‰ΩéÁÇπÊó∂ÔºåÂ∑¶‰æßÂõûÊ∫ØÈïøÂ∫¶Ë∂äÂ§ßÔºåË∂äÈúÄÁ°ÆËÆ§ÂâçÊñπËµ∞ÂäøÁöÑÂπ≥Á®≥ÊÄßÔºå‰ªéËÄåÊèêÂçáÂà§Êñ≠ÁöÑË∞®ÊÖéÂ∫¶‰∏éÂèØÈù†ÊÄß„ÄÇ')
WTdivRangeMax = input(title = 'Max of Lookback Range‰∏®ÊúÄÂ§ßÂõûÊ∫ØËåÉÂõ¥', defval = 60, group = 'Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø', tooltip = '‚ñ∂Ô∏é Controls the maximum distance between pivot points for divergence signals. A smaller Max value helps avoid detecting signals that are ‚Äútoo far to matter,‚Äù enhancing timeliness.\n‚ñ∂Ô∏é Áî®‰∫éÊéßÂà∂ËÉåÁ¶ª‰ø°Âè∑‰∏≠Êû¢ËΩ¥ÁÇπÁöÑÊúÄÂ§ßÈó¥ÈöîÔºåMax ÂÄºË∂äÂ∞èË∂äËÉΩÈÅøÂÖç‚ÄúÂ§™ËøúÊó†Êïà‚ÄùÁöÑËØÜÂà´ÔºåÊèêÈ´ò‰ø°Âè∑Êó∂ÊïàÊÄß„ÄÇ')
WTdivRangeMin = input(title = 'Min of Lookback Range‰∏®ÊúÄÂ∞èÂõûÊ∫ØËåÉÂõ¥', defval = 5, group = 'Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø', tooltip = '‚ñ∂Ô∏é Controls the spacing between pivot points for divergence signals. A higher Min value avoids signals that are ‚Äútoo close to count,‚Äù improving reliability.\n‚ñ∂Ô∏é Áî®‰∫éÊéßÂà∂ËÉåÁ¶ª‰ø°Âè∑‰∏≠Êû¢ËΩ¥ÁÇπÁöÑÈó¥Èöî„ÄÇËæÉÈ´òÁöÑ Min ÂÄºÂèØÈÅøÂÖç‚ÄúÈó¥Ë∑ùËøáËøë‰∏çËÆ°ÂÖ•‚ÄùÁöÑÊÉÖÂÜµÔºå‰ªéËÄåÊèêÂçá‰ø°Âè∑ÂèØÈù†ÊÄß„ÄÇ')

WTbearColor = color.fuchsia
WTbullColor = color.aqua
WThiddenBullColor = color.new(color.aqua, 50)
WThiddenBearColor = color.new(color.fuchsia, 50)
WTtextColor = color.white
WTnoneColor = color.new(color.white, 100)

//WTlineRaw="Wave Trend", SignalLineRaw="Signal", HistRaw="Histogram"
WTosc = WTdivSRC == 'Wave Trend' ? WTlineRawNorm : WTdivSRC == 'Signal' ? SignalLineRawNorm : WTdivSRC == 'Histogram' ? HistRawNorm : WTlineRawNorm

WTpivotLowFound = na(ta.pivotlow(WTosc, WTpvtLBl, WTpvtLBr)) ? false : true
WTpivotHighFound = na(ta.pivothigh(WTosc, WTpvtLBl, WTpvtLBr)) ? false : true
WTinRange(cond) =>
    WTbarsSincePivot = ta.barssince(cond == true)
    WTdivRangeMin <= WTbarsSincePivot and WTbarsSincePivot <= WTdivRangeMax

//------------------------------------------------------------------------------
// Regular Bullish
// WTosc: Higher Low
WToscHL = WTosc[WTpvtLBr] > ta.valuewhen(WTpivotLowFound, WTosc[WTpvtLBr], 1) and WTinRange(WTpivotLowFound[1])

// Price: Lower Low
WTdivPriceLL = low[WTpvtLBr] < ta.valuewhen(WTpivotLowFound, low[WTpvtLBr], 1)
WTbullCond = EnableWaveTrend and WTshowRegularDiv and WTdivPriceLL and WToscHL and WTpivotLowFound
plot(WTpivotLowFound ? WTosc[WTpvtLBr] : na, offset = -WTpvtLBr, title = 'WT Reg. Bull‰∏®Â∏∏ËßÑÁúãÊ∂®ËÉåÁ¶ª', color = WTbullCond ? WTbullColor : WTnoneColor)
plotshape(WTbullCond ? WTosc[WTpvtLBr] : na, offset = -WTpvtLBr, title = 'WT Reg. Bull Label‰∏®Â∏∏ËßÑÁúãÊ∂®ËÉåÁ¶ªÊ†áÁ≠æ', text = '‚ñ≤', style = shape.labelup, location = location.absolute, color = WTbullColor, textcolor = color.new(WTtextColor, 0))

//------------------------------------------------------------------------------
// Hidden Bullish
// WTosc: Lower Low
WToscLL = WTosc[WTpvtLBr] < ta.valuewhen(WTpivotLowFound, WTosc[WTpvtLBr], 1) and WTinRange(WTpivotLowFound[1])

// Price: Higher Low
WTdivPriceHL = low[WTpvtLBr] > ta.valuewhen(WTpivotLowFound, low[WTpvtLBr], 1)
WThiddenBullCond = EnableWaveTrend and WTshowHiddenDiv and WTdivPriceHL and WToscLL and WTpivotLowFound
plot(WTpivotLowFound ? WTosc[WTpvtLBr] : na, offset = -WTpvtLBr, title = 'WT Hidden Bull‰∏®ÈöêËóèÁúãÊ∂®ËÉåÁ¶ª', color = WThiddenBullCond ? WThiddenBullColor : WTnoneColor)
plotshape(WThiddenBullCond ? WTosc[WTpvtLBr] : na, offset = -WTpvtLBr, title = 'WT Hidden Bull Label‰∏®ÈöêËóèÁúãÊ∂®ËÉåÁ¶ªÊ†áÁ≠æ', text = '‚ñ≥', style = shape.labelup, location = location.absolute, color = WThiddenBullColor, textcolor = color.new(WTtextColor, 0))

//------------------------------------------------------------------------------
// Regular Bearish
// WTosc: Lower High
WToscLH = WTosc[WTpvtLBr] < ta.valuewhen(WTpivotHighFound, WTosc[WTpvtLBr], 1) and WTinRange(WTpivotHighFound[1])

// Price: Higher High
WTdivPriceHH = high[WTpvtLBr] > ta.valuewhen(WTpivotHighFound, high[WTpvtLBr], 1)
WTbearCond = EnableWaveTrend and WTshowRegularDiv and WTdivPriceHH and WToscLH and WTpivotHighFound
plot(WTpivotHighFound ? WTosc[WTpvtLBr] : na, offset = -WTpvtLBr, title = 'WT Reg. Bear‰∏®Â∏∏ËßÑÁúãË∑åËÉåÁ¶ª', color = WTbearCond ? WTbearColor : WTnoneColor)
plotshape(WTbearCond ? WTosc[WTpvtLBr] : na, offset = -WTpvtLBr, title = 'WT Reg. Bear Label‰∏®Â∏∏ËßÑÁúãË∑åËÉåÁ¶ªÊ†áÁ≠æ', text = '‚ñº', style = shape.labeldown, location = location.absolute, color = WTbearColor, textcolor = color.new(WTtextColor, 0))

//------------------------------------------------------------------------------
// Hidden Bearish
// WTosc: Higher High
WToscHH = WTosc[WTpvtLBr] > ta.valuewhen(WTpivotHighFound, WTosc[WTpvtLBr], 1) and WTinRange(WTpivotHighFound[1])

// Price: Lower High
WTdivPriceLH = high[WTpvtLBr] < ta.valuewhen(WTpivotHighFound, high[WTpvtLBr], 1)
WThiddenBearCond = EnableWaveTrend and WTshowHiddenDiv and WTdivPriceLH and WToscHH and WTpivotHighFound
plot(WTpivotHighFound ? WTosc[WTpvtLBr] : na, offset = -WTpvtLBr, title = 'WT Hidden Bear‰∏®ÈöêËóèÁúãË∑åËÉåÁ¶ª', color = WThiddenBearCond ? WThiddenBearColor : WTnoneColor)
plotshape(WThiddenBearCond ? WTosc[WTpvtLBr] : na, offset = -WTpvtLBr, title = 'WT Hidden Bear Label‰∏®ÈöêËóèÁúãË∑åËÉåÁ¶ªÊ†áÁ≠æ', text = '‚ñΩ', style = shape.labeldown, location = location.absolute, color = WThiddenBearColor, textcolor = color.new(WTtextColor, 0))
// Wave Trend‰∏®Ê≥¢Êµ™Ë∂ãÂäø


// Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞
EnablePAI = input.bool(true, title='Enable Price Action Index‰∏®ÂêØÁî®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', tooltip = '‚ñ∂Ô∏é The Price Action Index is a composite indicator that integrates price momentum with volatility dispersion to evaluate the direction and strength of market trends. It effectively identifies consolidation ranges, breakout points, and potential reversals. When used alongside value thresholds and divergence signals, PAI becomes a powerful tool for precise trend analysis.\n‚ñ∂Ô∏é ‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞ÊòØ‰∏ÄÁßçËûçÂêà‰ª∑Ê†ºÂä®Èáè‰∏éÊ≥¢Âä®Á¶ªÊï£Â∫¶ÁöÑÂ§çÂêàÂûãÊåáÊ†áÔºåÁî®‰∫éË°°ÈáèÂ∏ÇÂú∫Ë∂ãÂäøÁöÑÊñπÂêë‰∏éÂº∫Â∫¶„ÄÇÂÆÉËÉΩÊúâÊïàËØÜÂà´ÈúáËç°Âå∫Èó¥„ÄÅÁ™ÅÁ†¥Êó∂Êú∫‰∏éÊΩúÂú®ÂèçËΩ¨ÁÇπÔºåÁªìÂêàÊï∞ÂÄºÂå∫Èó¥‰∏éËÉåÁ¶ª‰ø°Âè∑‰ΩøÁî®ÔºåÂ∞ÜÊòæËëóÊèêÂçáË∂ãÂäøÂà§Êñ≠ÁöÑÂáÜÁ°ÆÊÄß„ÄÇ')
TF0 = 'None‰∏®Á¶ÅÁî®' 
TF1 = 'Auto-Steps‰∏®Ëá™Âä®Ê≠•Ëøõ' 
TF2 = 'TF Multiple‰∏®Êó∂Èó¥Ê°ÜÊû∂ÂÄçÊï∞' 
TF3 = 'Fixed TF‰∏®Âõ∫ÂÆöÊó∂Èó¥Ê°ÜÊû∂' 
UseHTFrepaint = input.bool(false, 'Use HTF Repaint‰∏®‰ΩøÁî®Êó∂Èó¥Ê°ÜÊû∂ÈáçÁªò', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', tooltip = '‚ñ∂Ô∏é The Repaint HTF feature allows the indicator to display higher timeframe (HTF) data in real-time using the most recent bar‚Äôs values. This helps provide timely signals based on larger trends, but may introduce repainting as HTF candles are still forming.\n‚ñ∂Ô∏é ÂêØÁî®‚ÄúÈáçÁªò HTF‚ÄùÂäüËÉΩÂêéÔºåÊåáÊ†áÂ∞Ü‰ΩøÁî®ÂΩìÂâçÂë®ÊúüÊúÄËøë‰∏ÄÊ†π K Á∫øÁöÑÊï∞ÂÄºÊù•ÂÆûÊó∂ÊòæÁ§∫È´òÊó∂Èó¥Âë®ÊúüÔºàHTFÔºâÁöÑÊï∞ÊçÆ„ÄÇËøôÊúâÂä©‰∫éÂü∫‰∫éÊõ¥Â§ßË∂ãÂäøÊèêÂâçÂèëÂá∫‰ø°Âè∑Ôºå‰ΩÜÁî±‰∫é HTF ÁöÑ K Á∫øÂ∞öÊú™Êî∂ÁõòÔºåÂèØËÉΩ‰ºöÂá∫Áé∞ÈáçÁªòÁé∞Ë±°„ÄÇ')
HTFmode = input.string(TF0, 'Select HTF Mode‰∏®ÈÄâÊã©HTFÊ®°Âºè', options=[TF0, TF1, TF2, TF3], group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞')
TFmult = input.float(3, 'TF Multiple‰∏®Êó∂Èó¥Ê°ÜÊû∂ÂÄçÊï∞', minval=1, group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞')
FixedTF = input.timeframe('D', 'Fixed TF‰∏®Âõ∫ÂÆöÊó∂Èó¥Ê°ÜÊû∂', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞')

// HTF is being used.
var useHTF = HTFmode != TF0
//var bool	i_invert    = input(true,      "Invert Colors")

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî PineCoders MTF Selection Framework functions
// ‚Äî‚Äî‚Äî‚Äî‚Äî Converts current "timeframe.multiplier" plus the TF into minutes of type float.
GetCurrentTFinMinutes() =>
    CurrentTFinMinutes = timeframe.multiplier * (timeframe.isseconds ? 1. / 60. : timeframe.isminutes ? 1. : timeframe.isdaily ? 1440. : timeframe.isweekly ? 10080. : timeframe.ismonthly ? 43800. : na)
    CurrentTFinMinutes

// ‚Äî‚Äî‚Äî‚Äî‚Äî Returns resolution of TFstring period in minutes.
GetTFInMinutes(TFstring) =>
    // TFstring: resolution of any TF (in "timeframe.period" string format).
    request.security(syminfo.tickerid, TFstring, GetCurrentTFinMinutes())

// ‚Äî‚Äî‚Äî‚Äî‚Äî Given current resolution, returns next step of HTF.
GetNextHTFstep(CurrentMinutes) =>
    // CurrentMinutes: current TF in fractional minutes.
    CurrentMinutes <= 1 ? '15' : CurrentMinutes <= 5 ? '60' : CurrentMinutes <= 30 ? '240' : CurrentMinutes <= 60 ? '1D' : CurrentMinutes <= 360 ? '3D' : CurrentMinutes <= 1440 ? '1W' : CurrentMinutes <= 10080 ? '1M' : '12M'

// ‚Äî‚Äî‚Äî‚Äî‚Äî Returns a multiple of current resolution as a string in "timeframe.period" format usable with "security()".
GetTFmultiple(CurrentMinutes, Multiplier) =>
    // CurrentMinutes:  current resolution in minutes, in the fractional format supplied by GetCurrentTFinMinutes() companion function.
    // Multiplier: Multiple of current TF to be calculated.
    // Convert current float TF in minutes to target string TF in "timeframe.period" format.
    TargetTFinMinutes = CurrentMinutes * math.max(Multiplier, 1)
    TargetTFinMinutes <= 0.083 ? '5S' : TargetTFinMinutes <= 0.251 ? '15S' : TargetTFinMinutes <= 0.501 ? '30S' : TargetTFinMinutes <= 1440 ? str.tostring(math.round(TargetTFinMinutes)) : TargetTFinMinutes <= 43800 ? str.tostring(math.round(math.min(TargetTFinMinutes / 1440, 365))) + 'D' : str.tostring(math.round(math.min(TargetTFinMinutes / 43800, 12))) + 'M'

// ‚Äî‚Äî‚Äî‚Äî‚Äî HTF calcs
// Get current resolution in float minutes.
var resInMinutes = GetCurrentTFinMinutes()
// Get HTF from user-defined mode.
var HTF = HTFmode == TF0 ? timeframe.period : HTFmode == TF1 ? GetNextHTFstep(resInMinutes) : HTFmode == TF2 ? GetTFmultiple(resInMinutes, TFmult) : FixedTF

// Methods of Dispersion {
string DispStdev = 'Standard Deviation‰∏®Ê†áÂáÜÂ∑Æ'
CalcStdev(PriceSRC, LBlen) =>
    ta.stdev(PriceSRC, LBlen)
string DispVariance = 'Variance‰∏®ÊñπÂ∑Æ'
CalcVariance(PriceSRC, LBlen) =>
    ta.variance(PriceSRC, LBlen)
string DispCV = 'Coefficient of Variation‰∏®ÂèòÂºÇÁ≥ªÊï∞'
CalcCV(PriceSRC, LBlen) =>
    ta.stdev(PriceSRC, LBlen)/ta.sma(PriceSRC, LBlen)
string DispSN = 'Signal-to-Noise‰∏®‰ø°Âô™ÊØî'
CalcSN(PriceSRC, LBlen) =>
    ta.sma(PriceSRC, LBlen)/ta.stdev(PriceSRC, LBlen)
string DispSN2 = 'Signal-to-Noise¬≤‰∏®‰ø°Âô™ÊØîÂπ≥Êñπ'
CalcSN2(PriceSRC, LBlen) =>
    math.pow(ta.sma(PriceSRC, LBlen), 2) / math.pow(ta.stdev(PriceSRC, LBlen), 2)
string DispIndex = 'Index of Dispersion‰∏®Á¶ªÊï£ÊåáÊï∞'
CalcDisIndex(PriceSRC, LBlen) =>
    math.pow(ta.variance(PriceSRC, LBlen), 2)/ta.sma(PriceSRC, LBlen)
string DispEfficiency = 'Efficiency‰∏®Ë∂ãÂäøÊïàÁéáÊØî'
CalcEfficiency(PriceSRC, LBlen) =>
    math.pow(ta.stdev(PriceSRC, LBlen), 2)/math.pow(ta.sma(PriceSRC, LBlen), 2)
string DispRange = 'High-Low Range‰∏®È´ò‰Ωé‰ª∑Âå∫Èó¥'
CalcRange(PriceSRC, LBlen) =>
    ta.highest(LBlen) - ta.lowest(LBlen)
// }

// Price Action Index Inputs {
PriceSRC = input.source(defval=close, title='Data Source‰∏®Êï∞ÊçÆÊ∫ê', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞')
LBlen = input.int(defval=20, title='Stochastic‰∏®ÈöèÊú∫ÊåáÊï∞', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', inline='Stoch')
LBsmooth = input.int(defval=3, title='', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', inline='Stoch', tooltip = '‚ñ∂Ô∏é The first value is the lookback length for your traditional Stochastic Oscillator. The second is the smoothing length.\n‚ñ∂Ô∏é Á¨¨‰∏Ä‰∏™Êï∞ÂÄºÊòØ‰º†ÁªüÈöèÊú∫ÈúáËç°ÊåáÊ†áÁöÑÂõûÊ∫ØÂë®ÊúüÔºåÁ¨¨‰∫å‰∏™Êï∞ÂÄºÊòØÂÖ∂Âπ≥ÊªëÂ§ÑÁêÜÂë®Êúü„ÄÇ')
DispMethod = input.string(DispStdev, options=[DispStdev, DispVariance, DispCV, DispSN, DispSN2, DispIndex, DispEfficiency, DispRange], title='Dispersion‰∏®Á¶ªÊï£Â∫¶', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', inline='Dispersion')
DispLen = input.int(defval=20, title='', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', inline='Dispersion', tooltip = '‚ñ∂Ô∏é The dropdown is a selection of methods of calculating dispersion. The box that follows is the lookback length to measure.\n‚ñ∂Ô∏é ‰∏ãÊãâËèúÂçïÁî®‰∫éÈÄâÊã©ËÆ°ÁÆóÁ¶ªÊï£Â∫¶ÁöÑÊñπÊ≥ïÔºåÂêéÈù¢ÁöÑËæìÂÖ•Ê°ÜÂàôÁî®‰∫éËÆæÁΩÆÂØπÂ∫îÁöÑÂõûÊ∫ØÂë®Êúü„ÄÇ')

StraddleArea = input.float(defval=5.0, title='Straddle Area‰∏®ÈúáËç°Âå∫Èó¥', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', tooltip = '‚ñ∂Ô∏é This value defines the size of the \'Straddle Area\' where price is within consolidation and the limits where it breaks out.\n‚ñ∂Ô∏é ËØ•Êï∞ÂÄºÂÆö‰πâ‰∫Ü‚ÄúÈúáËç°Âå∫Èó¥‚ÄùÁöÑËåÉÂõ¥ÔºåÂΩì‰ª∑Ê†ºÂú®ËØ•ËåÉÂõ¥ÂÜÖÊ≥¢Âä®Êó∂Ë°®Á§∫Â§Ñ‰∫éÊï¥ÁêÜÁä∂ÊÄÅÔºåÁ™ÅÁ†¥ËØ•ËåÉÂõ¥ÂàôËßÜ‰∏∫Á™ÅÁ†¥‰ø°Âè∑„ÄÇ')
UseBarColors = input.bool(defval=false, title='Use Bar Colors‰∏®‰ΩøÁî®KÁ∫øÁùÄËâ≤', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', tooltip = '‚ñ∂Ô∏é Check this box if you want to color candles/bars similar to the color of the Price Action Index.\n‚ñ∂Ô∏é ÂãæÈÄâÊ≠§ÈÄâÈ°πÂèØ‰ΩøKÁ∫øÊü±Áä∂È¢úËâ≤‰∏é‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞ÁöÑÈ¢úËâ≤‰øùÊåÅ‰∏ÄËá¥„ÄÇ')
PAIshowLabels = input.bool(false, title = 'Show Bull & Bear Labels‰∏®ÊòæÁ§∫Â§öÁ©∫Ê†áÁ≠æ', group = 'Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', tooltip = '‚ñ∂Ô∏é Enabling this will display bull/bear trend strength labels near the price for visual reference, helping highlight moments of strong trend direction.\n‚ñ∂Ô∏é ÂêØÁî®ÂêéÂ∞ÜÂú®‰ª∑Ê†ºÈôÑËøëÊòæÁ§∫Â§öÁ©∫Ë∂ãÂäøÂº∫Â∫¶Ê†áÁ≠æÔºåÊèê‰æõËßÜËßâÂèÇËÄÉÔºåÊúâÂä©‰∫éÁ™ÅÂá∫Ë∂ãÂäøÊòéÊòæÁöÑÊó∂Âàª„ÄÇ')

// Divergence Indicator Inputs {
PAIshowRegularDiv = input.bool(true, title='Show Regular Divergences‰∏®ÊòæÁ§∫Â∏∏ËßÑËÉåÁ¶ª', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞')
PAIshowHiddenDiv = input.bool(false, title='Show Hidden Divergences‰∏®ÊòæÁ§∫ÈöêËóèËÉåÁ¶ª', group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞')

PAIpvtLBr = input.int(title='Pivot Lookback Right‰∏®ÂêëÂè≥ÂõûÊ∫ØÈïøÂ∫¶', defval=2, group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', tooltip = '‚ñ∂Ô∏é Confirms a pivot only if future candles don‚Äôt surpass the current value. Higher values delay confirmation but improve stability and reduce false signals.\n‚ñ∂Ô∏é ‰ªÖÂΩìÂâçÊñπÁöÑ K Á∫øÈÉΩÊú™Á™ÅÁ†¥ÂΩìÂâçÂÄºÊó∂ÔºåÊâçËÉΩÁ°ÆËÆ§ÂÖ∂‰∏∫Êû¢ËΩ¥ÁÇπ„ÄÇÊï∞ÂÄºË∂äÂ§ßÔºåÁ°ÆËÆ§Ë∂äÊªûÂêéÔºå‰ΩÜÊõ¥Á®≥ÂÆöÔºåÂèØÂáèÂ∞ëËØØÊä•„ÄÇ')
PAIpvtLBl = input.int(title='Pivot Lookback Left‰∏®ÂêëÂ∑¶ÂõûÊ∫ØÈïøÂ∫¶', defval=2, group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', tooltip = '‚ñ∂Ô∏é When identifying highs/lows, a larger left-side lookback requires more stable past movement, making detection more cautious but more reliable.\n‚ñ∂Ô∏é Áî®‰∫éËØÜÂà´ÂΩìÂâçÊòØÂê¶‰∏∫È´ò/‰ΩéÁÇπÊó∂ÔºåÂ∑¶‰æßÂõûÊ∫ØÈïøÂ∫¶Ë∂äÂ§ßÔºåË∂äÈúÄÁ°ÆËÆ§ÂâçÊñπËµ∞ÂäøÁöÑÂπ≥Á®≥ÊÄßÔºå‰ªéËÄåÊèêÂçáÂà§Êñ≠ÁöÑË∞®ÊÖéÂ∫¶‰∏éÂèØÈù†ÊÄß„ÄÇ')
PAIdivRangeMax = input.int(title='Max of Lookback Range‰∏®ÊúÄÂ§ßÂõûÊ∫ØËåÉÂõ¥', defval=10, group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', tooltip = '‚ñ∂Ô∏é Controls the maximum distance between pivot points for divergence signals. A smaller Max value helps avoid detecting signals that are ‚Äútoo far to matter,‚Äù enhancing timeliness.\n‚ñ∂Ô∏é Áî®‰∫éÊéßÂà∂ËÉåÁ¶ª‰ø°Âè∑‰∏≠Êû¢ËΩ¥ÁÇπÁöÑÊúÄÂ§ßÈó¥ÈöîÔºåMax ÂÄºË∂äÂ∞èË∂äËÉΩÈÅøÂÖç‚ÄúÂ§™ËøúÊó†Êïà‚ÄùÁöÑËØÜÂà´ÔºåÊèêÈ´ò‰ø°Âè∑Êó∂ÊïàÊÄß„ÄÇ')
PAIdivRangeMin = input.int(title='Min of Lookback Range‰∏®ÊúÄÂ∞èÂõûÊ∫ØËåÉÂõ¥', defval=2, group='Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞', tooltip = '‚ñ∂Ô∏é Controls the spacing between pivot points for divergence signals. A higher Min value avoids signals that are ‚Äútoo close to count,‚Äù improving reliability.\n‚ñ∂Ô∏é Áî®‰∫éÊéßÂà∂ËÉåÁ¶ª‰ø°Âè∑‰∏≠Êû¢ËΩ¥ÁÇπÁöÑÈó¥Èöî„ÄÇËæÉÈ´òÁöÑ Min ÂÄºÂèØÈÅøÂÖç‚ÄúÈó¥Ë∑ùËøáËøë‰∏çËÆ°ÂÖ•‚ÄùÁöÑÊÉÖÂÜµÔºå‰ªéËÄåÊèêÂçá‰ø°Âè∑ÂèØÈù†ÊÄß„ÄÇ')

PAIbearColor = color.red
PAIbullColor = color.green
PAIhiddenBullColor = color.new(color.green, 50)
PAIhiddenBearColor = color.new(color.red, 50)
PAItextColor = color.white
PAInoneColor = color.new(color.white, 100)
// }

// PAI Calcs {
PAI(PriceSRC, Disp, LBlen) =>
    DispValue = CalcStdev(PriceSRC, DispLen)
    if DispMethod == DispVariance
        DispValue := CalcVariance(PriceSRC, DispLen)
        DispValue
    else
        if DispMethod == DispCV
            DispValue := CalcCV(PriceSRC, DispLen)
            DispValue
        else
            if DispMethod == DispSN
                DispValue := -CalcSN(PriceSRC, DispLen)
                DispValue
            else
                if DispMethod == DispSN2
                    DispValue := -CalcSN2(PriceSRC, DispLen)
                    DispValue
                else
                    if DispMethod == DispIndex
                        DispValue := CalcDisIndex(PriceSRC, DispLen)
                        DispValue
                    else
                        if DispMethod == DispEfficiency
                            DispValue := CalcEfficiency(PriceSRC, DispLen)
                            DispValue
                        else
                            if DispMethod == DispRange
                                DispValue := CalcRange(PriceSRC, DispLen)
                                DispValue

    PriceMomentum = PriceSRC == close ? (ta.sma(ta.stoch(close, high, low, LBlen), LBsmooth) - 50) / 50 : (ta.sma(ta.stoch(PriceSRC, PriceSRC, PriceSRC, LBlen), LBsmooth) - 50) / 50
    VolatilityStoch = ta.stoch(DispValue, DispValue, DispValue, LBlen)
    PriceMomentum * VolatilityStoch

GetHTFdata(Symbol, CurrentMinutes, SrcFunc, EnableRepaint) =>
    request.security(Symbol, CurrentMinutes, SrcFunc[not EnableRepaint and barstate.isrealtime ? 1 : 0])[EnableRepaint or barstate.isrealtime ? 0 : 1]
PAIvalue = not useHTF ? PAI(PriceSRC, DispLen, LBlen) : GetHTFdata(syminfo.tickerid, HTF, PAI(PriceSRC, DispLen, LBlen), UseHTFrepaint)
// }

// Output Conditionals {
isStraddling = PAIvalue < StraddleArea and PAIvalue > -StraddleArea
isBullishRally = PAIvalue > 40
isBearishDrop = PAIvalue < -40

color PAIcolor = color.black
if isStraddling
    PAIcolor := color.yellow
    PAIcolor
if PAIvalue > StraddleArea
    PAIcolor := color.lime
    PAIcolor
if PAIvalue < -StraddleArea
    PAIcolor := color.red
    PAIcolor
// }

// Plots {
PAInormalized = (PAIvalue + 100) / 2
plot(EnablePAI ? PAInormalized : na, title='PAI Normalized', color=color.new(PAIcolor, 0), style=plot.style_stepline)
barcolor(EnablePAI and UseBarColors ? PAIcolor : na, editable=false, title='Bar Colors')

fill(OverboughtA, OverboughtB, color=EnablePAI and isBullishRally ? color.new(color.red, 65) : na, title='Overbought Area‰∏®Ë∂Ö‰π∞Âå∫')
fill(OversoldA, OversoldB, color=EnablePAI and isBearishDrop ? color.new(color.lime, 65) : na, title='Oversold Area‰∏®Ë∂ÖÂçñÂå∫')

barcolor(UseBarColors ? PAIcolor : na, editable=false, title='Bar Colors')
// }

// Divergence Plots {
PAIosc = PAInormalized
PAIpivotLowFound = na(ta.pivotlow(PAIosc, PAIpvtLBl, PAIpvtLBr)) ? false : true
PAIpivotHighFound = na(ta.pivothigh(PAIosc, PAIpvtLBl, PAIpvtLBr)) ? false : true
PAIinRange(PAIcond) =>
    PAIbarsSincePivot = ta.barssince(PAIcond == true)
    PAIdivRangeMin <= PAIbarsSincePivot and PAIbarsSincePivot <= PAIdivRangeMax

//------------------------------------------------------------------------------
// Regular Bullish
// PAIosc: Higher Low

PAIoscHL = PAIosc[PAIpvtLBr] > ta.valuewhen(PAIpivotLowFound, PAIosc[PAIpvtLBr], 1) and PAIinRange(PAIpivotLowFound[1])

// Price: Lower Low
PAIdivPriceLL = low[PAIpvtLBr] < ta.valuewhen(PAIpivotLowFound, low[PAIpvtLBr], 1)
PAIbullCond = PAIshowRegularDiv and PAIdivPriceLL and PAIoscHL and PAIpivotLowFound
plot(EnablePAI and PAIbullCond ? PAIosc[PAIpvtLBr] : na, offset=-PAIpvtLBr, title='PAI Reg. Bull‰∏®Â∏∏ËßÑÁúãÊ∂®ËÉåÁ¶ª', color=PAIbullCond ? PAIbullColor : PAInoneColor)
plotshape(EnablePAI and PAIbullCond ? PAIosc[PAIpvtLBr] : na, offset=-PAIpvtLBr, title='PAI Reg. Bull Label‰∏®Â∏∏ËßÑÁúãÊ∂®ËÉåÁ¶ªÊ†áÁ≠æ', text='‚ñ≤', style=shape.labelup, location=location.absolute, color=PAIbullColor, textcolor=color.new(PAItextColor, 0))
//------------------------------------------------------------------------------
// Hidden Bullish
// PAIosc: Lower Low

PAIoscLL = PAIosc[PAIpvtLBr] < ta.valuewhen(PAIpivotLowFound, PAIosc[PAIpvtLBr], 1) and PAIinRange(PAIpivotLowFound[1])

// Price: Higher Low
PAIdivPriceHL = low[PAIpvtLBr] > ta.valuewhen(PAIpivotLowFound, low[PAIpvtLBr], 1)
PAIhiddenBullCond = PAIshowHiddenDiv and PAIdivPriceHL and PAIoscLL and PAIpivotLowFound
plot(EnablePAI and PAIpivotLowFound ? PAIosc[PAIpvtLBr] : na, offset=-PAIpvtLBr, title='PAI Hidden Bull‰∏®ÈöêËóèÁúãÊ∂®ËÉåÁ¶ª', color=PAIhiddenBullCond ? PAIhiddenBullColor : PAInoneColor)
plotshape(EnablePAI and PAIhiddenBullCond ? PAIosc[PAIpvtLBr] : na, offset=-PAIpvtLBr, title='PAI Hidden Bull Label‰∏®ÈöêËóèÁúãÊ∂®ËÉåÁ¶ªÊ†áÁ≠æ', text='‚ñ≥', style=shape.labelup, location=location.absolute, color=PAIhiddenBullColor, textcolor=color.new(PAItextColor, 0))
//------------------------------------------------------------------------------
// Regular Bearish
// PAIosc: Lower High

PAIoscLH = PAIosc[PAIpvtLBr] < ta.valuewhen(PAIpivotHighFound, PAIosc[PAIpvtLBr], 1) and PAIinRange(PAIpivotHighFound[1])

// Price: Higher High
PAIdivPriceHH = high[PAIpvtLBr] > ta.valuewhen(PAIpivotHighFound, high[PAIpvtLBr], 1)
PAIbearCond = PAIshowRegularDiv and PAIdivPriceHH and PAIoscLH and PAIpivotHighFound
plot(EnablePAI and PAIpivotHighFound ? PAIosc[PAIpvtLBr] : na, offset=-PAIpvtLBr, title='PAI Reg. Bear‰∏®Â∏∏ËßÑÁúãË∑åËÉåÁ¶ª', color=PAIbearCond ? PAIbearColor : PAInoneColor)
plotshape(EnablePAI and PAIbearCond ? PAIosc[PAIpvtLBr] : na, offset=-PAIpvtLBr, title='PAI Reg. Bear Label‰∏®Â∏∏ËßÑÁúãË∑åËÉåÁ¶ª', text='‚ñº', style=shape.labeldown, location=location.absolute, color=PAIbearColor, textcolor=color.new(PAItextColor, 0))

//------------------------------------------------------------------------------
// Hidden Bearish
// PAIosc: Higher High

PAIoscHH = PAIosc[PAIpvtLBr] > ta.valuewhen(PAIpivotHighFound, PAIosc[PAIpvtLBr], 1) and PAIinRange(PAIpivotHighFound[1])

// Price: Lower High
PAIdivPriceLH = high[PAIpvtLBr] < ta.valuewhen(PAIpivotHighFound, high[PAIpvtLBr], 1)
PAIhiddenBearCond = PAIshowHiddenDiv and PAIdivPriceLH and PAIoscHH and PAIpivotHighFound
plot(EnablePAI and PAIpivotHighFound ? PAIosc[PAIpvtLBr] : na, offset=-PAIpvtLBr, title='PAI Hidden Bear‰∏®ÈöêËóèÁúãË∑åËÉåÁ¶ª', color=PAIhiddenBearCond ? PAIhiddenBearColor : PAInoneColor)
plotshape(EnablePAI and PAIhiddenBearCond ? PAIosc[PAIpvtLBr] : na, offset=-PAIpvtLBr, title='PAI Hidden Bear Label‰∏®ÈöêËóèÁúãË∑åËÉåÁ¶ªÊ†áÁ≠æ', text='‚ñΩ', style=shape.labeldown, location=location.absolute, color=PAIhiddenBearColor, textcolor=color.new(PAItextColor, 0))
// }

// Conditions {
isBullishBreakout = ta.crossover(PAIvalue, StraddleArea)
isBullTop = ta.crossunder(PAIvalue, 80)
isBearishBreakout = ta.crossunder(PAIvalue, -StraddleArea)
isBearBottom = ta.crossover(PAIvalue, -80)
// }

BullishLabel(x, y, LabelText, PAIcolor = color.white) =>
    var label PAIlabel = label.new(x, y, LabelText, color = #00000000, style = label.style_label_left)
    label.set_xy(PAIlabel, x, y)
    label.set_text(PAIlabel, LabelText)
    label.set_textcolor(PAIlabel, PAIcolor)
    PAIlabel
OversoldLabelY = 7.5

BearishLabel(x, y, LabelText, PAIcolor = color.white) =>
    var label PAIlabel = label.new(x, y, LabelText, color = #00000000, style = label.style_label_left)
    label.set_xy(PAIlabel, x, y)
    label.set_text(PAIlabel, LabelText)
    label.set_textcolor(PAIlabel, PAIcolor)
    PAIlabel
OverboughtLabelY = 92.5

if EnablePAI and PAIshowLabels
    BullishLabel(bar_index, OversoldLabelY, 'Bullish')
    BearishLabel(bar_index, OverboughtLabelY, 'Bearish')

TrendCombined = PAInormalized

TrendLabelText = 
      TrendCombined >= 99 ? 'üî¥ 99% ‚ñº' :
      TrendCombined >= 98 ? 'üî¥ 98% ‚ñº' :
      TrendCombined >= 97 ? 'üî¥ 97% ‚ñº' :
      TrendCombined >= 95 ? 'üî¥ 95% ‚ñº' :
      TrendCombined >= 90 ? 'üî¥ 90% ‚ñº' :
      TrendCombined >= 85 ? 'üî¥ 85% ‚ñº' :
      TrendCombined >= 80 ? 'üî¥ 80% ‚ñº' :
      TrendCombined >= 75 ? '75% ‚ñº' :
      TrendCombined >= 70 ? '70% ‚ñº' :
      TrendCombined >= 65 ? '65% ‚ñº' :
      TrendCombined >= 60 ? '60% ‚ñº' :
      TrendCombined >= 55 ? '55% ‚ñº' :
      TrendCombined >= 50.5 ? '50% ‚ñº' :
      TrendCombined > 50 ? '50% ‚ñ≤' :
      TrendCombined >= 45 ? '55% ‚ñ≤' :
      TrendCombined >= 40 ? '60% ‚ñ≤' :
      TrendCombined >= 35 ? '65% ‚ñ≤' :
      TrendCombined >= 30 ? '70% ‚ñ≤' :
      TrendCombined >= 25 ? '75% ‚ñ≤' :
      TrendCombined >= 20 ? 'üü¢ 80% ‚ñ≤' :
      TrendCombined >= 15 ? 'üü¢ 85% ‚ñ≤' :
      TrendCombined >= 10 ? 'üü¢ 90% ‚ñ≤' :
      TrendCombined >= 5 ? 'üü¢ 95% ‚ñ≤' :
      TrendCombined >= 2 ? 'üü¢ 98% ‚ñ≤' :
      'üü¢ 99% ‚ñ≤'

if PAIshowLabels and EnablePAI
    label TrendCombLabel = label.new(bar_index, 50, text = TrendLabelText, color = color.rgb(0, 0, 0, 100), xloc = xloc.bar_index, style = label.style_label_left, textcolor = TrendCombined > 50 ? color.red : TrendCombined < 50 ? color.green : color.white, textalign = text.align_left)
    label.set_x(TrendCombLabel, bar_index)
    label.delete(TrendCombLabel[1])
// Price Action Index‰∏®‰ª∑Ê†ºË°å‰∏∫ÊåáÊï∞

